# proj10实训二：内存管理

## 背景了解：内存管理

------

​	本部分实训主要完成教学操作系统内存管理部分功能的实现。内存管理是操作系统中一个核心的功能，它负责分配、管理、优化和保护计算机系统的内存资源。

[TOC]

### 一、存储抽象的发展

​	早期的存储器是使用抽象的，每一个程序都直接访问物理内存。这就导致一些潜在问题：

（1）如果用户程序可以寻址内存的每个字节，它们就可以很容易地 (故意地或偶然地) 破坏操作系统，从而使整个系统慢慢地停止运行，除非有特殊的硬件保护 (IBM 360 的锁键模式)。

（2）使用这种模型，想要同时运行多个程序是很困难的。

​	要使多个应用程序同时处于内存中并且不互相影响，需要解决两个问题：**保护**和**重定位**。于是出现了一种存储抽象：**地址空间**。**地址空间**是一个进程可用于寻址内存的一套地址结合，每个进程都有一个自己的地址空间，并且这个地址空间独立于其他进程的地址空间。比较难的是给每个进程一个自己独有的地址空间，使得一个程序中的地址 28 所对应的物理地址与另一个程序中的地址 28 多对应的物理地址有所不同。

​	一个简单的方式是使用**动态重定位**，简单地把每个进程的地址空间映射到物理内存的不同部分，这个方法会为 CPU 配置两个特殊的硬件寄存器**基址寄存器**与**界限寄存器**。当使用基址寄存器与界限寄存器时，程序装载到内存中连续的空闲位置且装载期间无须重定位。当程序开始运行时，将程序的起始物理地址装载到基址寄存器中，程序的长度装载到界限寄存器中。当每次进程访问内存、取一条指令、读或写一个数据字，CPU 硬件会在把地址发送到内存总先前，自动将基址值加到进程发出地址值上。同时检查程序提供的地址是否大于或等于界限寄存器中的值，如果访问的地址超过界限则会产生错误并中止访问。

​	但是这里会有一个新问题，由于物理空间不可能做到无限，内存总会有超载的时候，因此不可能无限制的运行所有进程。这个时候有两种解决方法：（1）交换技术；（2）**虚拟内存**。

### 二、虚拟内存

​	虚拟内存的基本思想是：每个进程拥有自己的地址空间，这个空间被分割为多个块，每个块称作页面 (page) 或一页。page 拥有连续的地址范围，被映射到物理内存，但并不是所有 page 都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射；而引用到不在物理内存中的地址空间，由操作系统负责将缺失的部分装入物理内存用重新执行失败的指令。

（1）**分页**：地址可以通过索引、基址寄存器、段寄存器或其他方式产生。由程序产生的这些地址称为 虚拟地址 (virtual address)，它们构成可一个 虚拟地址空间 (virtual address space)。虚拟地址被送往 内存管理单元 (Memory Management Unit, MMU) 中，MMU 将虚拟地址转换为物理地址。其中物理内存使用**页框**对页进行存储。页框大小等于页的大小。

（2）**页表**：页表用于虚拟地址与物理内存之间的索引，以得出应用于该虚拟页面的页框号。虚拟地址被分为高位部分的虚拟页号和低位部分的偏移量。由页表项找到页框号，然后把页框号拼接到偏移量的高位端，以替换掉虚拟页号，形成送往内存的物理地址。

​	但是使用虚拟内存并不意味着可以高枕无忧，在地址转化的过程中也会出现异常与中断，正如实训一所学习到的，发生了异常中断就必须要有相应的处理程序。在虚拟内存中，我们更关注缺页相关的中断与异常。针对这些问题有对应的算法：

#### 2.1 页面置换算法

##### 1. 最优页面置换算法（OPT）

​	这是一个理想状态下的置换算法，它的性能理论上是最优的。这是因为它能够“预知”进程未来需要使用的页面，但在现实中显然操作系统是没有这个能力的。

##### 2. 最近未使用页面置换算法（NRU）

​	为使操作系统能够收集有用的统计信息，会为每个 page 设置两个状态位 modified 与 referenced，每次访问内存时将由硬件直接设置。如果硬件没有这两个状态位，则会使用缺页中断与时钟中断模拟：启动进程时将所有 page 标记为不在内存中；当访问任何一个页面时都会引发一次缺页中断，此时操作系统可以设置 referenced (由操作系统实现的内部表)，修改页表项使其指向正确的页面并设置为只读模式，然后重新启动引起缺页中断的指令；如果随后对该页面的修改又引发一次缺页中断，则操作系统设置这个页面的 modified 并将其改为读写模式。

​	可以利用 modified 与 referenced 构造一个简单的置换算法：referenced 被定期地清零，以标记这是一个最近没有被访问的 page。由此置换算法将 page 分为了四类

（1） 没有被访问过，没有被修改
（2） 没有被访问过，已被修改
（3） 已被访问，没有被修改
（4） 已被访问，已被修改

​	最近未被使用 (Not Recently Used, NRU) 易于理解和能够有效地实现实现。NRU 在淘汰 page 时，淘汰一个第二类 page 可能比第一类 page 要好一些。

##### 3. 最近最少使用页面置换算法（LRU）

​	基于对软件指令执行的观察，在前面几条指令频繁使用的页面很可能在后面的几条指令中被使用。反过来说，已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用。这样可以实现一个方法，在缺页中断时置换未使用时间最长的页面，这个策略称为 **最近最少使用 (Least Recently Used, LRU) 页面置换算法**。这个算法的问题在于实现难度较高，需要维护一个所有 page 的链表并在访问时间内更新（这个操作通常十分费时）。

##### 4. 先进先出页面置换算法（FIFO）

​	先进先出 (First-In First-Out, FIFO) 算法类似于队列的实现，当一个 page 被换入的时候，加入到 page 对队尾，当需要换出一个页面时将队首的页面换出。FIFO 有一个显而易见的问题，一个常用的 page 到达队首时将被换出 RAM，不久之后又会产生缺页中断将其换入 RAM，因此很少使用纯粹的 FIFO 算法。

#### 2.2 多级页表

​	前面提到，页表是存储PTE的一个内存分页，而PTE是描述VA与PA映射关系的entry。

​	多级页表结构分为PGD/PUD/PMD/PTE这几个层级，P代表page，G代表global，D代表目录（Director），U代表上级，M代表中间，T代表Table，E代表Entry，所以：

（1） PGD：page global director

（2） PUD：page upper director

（3） PMD：page middle director

（4） PTE：page table entry

​	PTE是页表项。他们之间的关系是层级结构，通过PGD访问到最低端的PTE，访问方式是上一层地址+偏移量(offset）。PTE+页内偏移量可以访问到具体的物理地址。





参考文献：

1. **内存管理(mmu/smmu)/内存分配原理/多级页表** 原文链接：https://blog.csdn.net/cy413026/article/details/135861816
2. **五分钟带你了解 计算机操作系统——内存管理（万字详解·图文）** 原文链接：https://blog.csdn.net/qq_62464995/article/details/129844907
