# proj10实训三：进程管理

## 背景了解：进程管理

------

[TOC]

### 一、知识补充

#### 1.1 进程

​	进程是一个具有一定独立功能的程序在一个数据集合上一次动态执行过程，每个进程都对应一个运行中的程序。进程一般具有以下状态：

（1）新生状态：表示进程刚刚创建，未完成初始化，不可被调度，下一个状态为就绪状态；

（2）就绪状态：表示进程可以被调度，但未被选择，其下一个状态为运行状态；

（3）运行状态：表示进程正在被执行，其可被中断迁移到就绪状态，也可以在运行结束后进入终止状态。此外，如果其需要等待某些进程执行，其可以进入阻塞状态；

（4）阻塞状态：表示进行需要等待外部事件完成，需要等待事件完成才能执行，下一个状态为就绪状态；

（5）终止状态：表示进程调度完成，不再被调度。

#### 1.2 进程控制

​	在内核中，每个进程都有一个数据结构保存其状态信息，也就是元数据。例如**进程标识符**，进程状态，虚拟内存状态，打开的文件等。这个数据结构称为进程控制块（PCB）。

​	**PCB的组织方式：**

​	1.链表：同一状态的进程其PCB成一链表，多个状态对应多个不同的链表。如就绪链表，阻塞链表。

​	2.索引表：同一状态的进程归入一个index表，多个状态对应多个不同的index表。如就绪索引表，阻塞索引表。

​	注：一般会选择链表，因为可能面临进程创建，销毁等调度导致进程状态发生变化，所以链表能够更加灵活的插入和删除。

### 二、相关调用

#### **2.1 创建进程**

​	在系统中，出现了创建新进程的请求后，OS就调用进程创建原语Creat，经过下面的步骤：
​	1.申请空白PCB，获得唯一标识，从PCB集合中获取空白PCB。
​	2.为新进程分配所需资源。
​	3.初始化进程控制块
​	4.如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列。

#### **2.2 加载和执行进程**

##### **（1）fork()函数的简单实现**：

​	对子进程分配内存；
​	复制父进程的内存和CPU寄存器到子进程里。

##### **（2）缺点**

​	在fork()之后，几乎都要**调用exec()**，导致fork()操作中**内存复制是没有作用的**，而且子进程将可能关闭打开的文件和连接，**开销昂贵**。

##### **（3）vfork()函数的简单实现：**

​	1.一个创建进程的系统调用，**不需要**创建一个同样的内存映像，只复制和当前地址空间相关的元数据，页表等。
​	2.使用**copy on write**技术，只有当对某个地址**写操作**的时候才会**触发异常**，将触发异常的页分成两份，让父进程和子进程分别拥有不同的地址。

#### **2.3 等待和终止进程**

##### **（1）wait()函数**

​	**wait()**系统调用是被父进程用来等待子进程的结束。

​	1. 为什么要让父进程使用wait()来等待子进程结束？

​	因为子进程的结束只能**释放用户空间**所占用的内存，他的**PCB**是存放在**内核中**的，用户空间释放完，**无法进行**系统调用删除PCB。所以需要**父进程帮助**它在内核中删除。

##### **（2）exit()函数**

​	进程结束执行后，它调用exit()，操作系统**解锁父进程**，并且将通过exit()传递得到的返回值为wait()调用的结果 。

​	1. 调用exit()后，会发生什么？

​	会将程序结果作为一个参数；关闭打开的文件，连接等；释放内存；释放大部分支持进程的操作系统结构；检查是否父进程是存活。

​	当子进程执行完exec()后还**没返回给wait()**回收PCB时，这一阶段，子进程处于**僵尸态**，也叫僵尸进程。

​	2. 操作系统**如何处理这些僵尸进程**的？

​	如果父进程先于子进程死亡，将没有进程等待子进程释放。Init进程会定期扫描PCB列表，如果有进程处于僵尸态就会代替父进程进行wait()。

#### 2.4 相关调度算法

- FCFS（先来先服务）
- SJF（短进程优先）
- HRRN（最高响应时间比优先）
- RR（轮询）
- MFQ（多级反馈队列）
- FSS（公平共享调度）